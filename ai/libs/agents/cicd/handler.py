"""CICD handler used by NATS controller."""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any, Callable, Dict, Optional

from libs.agents.cicd.git_client import GitClient, GitClientError
from libs.agents.orchestrator.orchestrator import Orchestrator
from libs.integrations.interfaces.llm import LLMService
from libs.shared.config import settings

logger = logging.getLogger(__name__)

PublishFn = Callable[[Dict[str, Any]], Any]


class CICDHandler:
    """Coordinates generation and git automation for NATS messages."""

    def __init__(self, llm: LLMService, git_client: GitClient, publish: PublishFn) -> None:
        self.orchestrator = Orchestrator(llm)
        self.git_client = git_client
        self.publish = publish

    # ---------- generate flow ----------
    async def handle_generate(self, payload: Dict[str, Any]) -> None:
        request_id = payload.get("request_id") or payload.get("run_id")
        if not request_id:
            raise ValueError("request_id is required")
        spec = payload.get("spec")
        if not spec:
            await self.publish_event(request_id, "failed", error="spec is required for now")
            return

        await self.publish_event(request_id, "started")
        run_id = request_id
        try:
            # run blocking orchestrator.start_run in a thread so we don't run into
            # "This event loop is already running" when orchestration uses asyncio inside
            import asyncio

            run_id = await asyncio.to_thread(self.orchestrator.start_run, spec, request_id)
            await self.publish_event(request_id, "generating", run_id=run_id)
            run = self.orchestrator.get_run(run_id)
            if not run or run.get("status") != "finished":
                await self.publish_event(request_id, "failed", run_id=run_id, error=run and run.get("error"))
                return
            artifact_path = run.get("artifact")
            preview = ""
            try:
                preview = Path(artifact_path).read_text(encoding="utf-8")[:500]
            except Exception:
                preview = ""
            await self.publish_event(
                request_id,
                "finished",
                run_id=run_id,
                artifact_path=artifact_path,
                preview=preview,
                mode=payload.get("mode", "suggest+run"),
            )
        except Exception as exc:  # noqa: BLE001
            logger.exception("generate failed: %s", exc)
            await self.publish_event(request_id, "failed", run_id=run_id, error=str(exc))

    # ---------- commit & push flow ----------
    async def handle_commit_push(self, payload: Dict[str, Any]) -> None:
        request_id = payload.get("request_id") or payload.get("run_id")
        if not request_id:
            raise ValueError("request_id is required")

        repo_url = payload.get("repo")
        if not repo_url:
            await self.publish_event(request_id, "failed", error="repo is required")
            return

        run_id = payload.get("run_id")
        files = payload.get("files") or []
        branch = payload.get("branch") or f"ai/generated/{run_id or request_id}"
        target_branch = payload.get("target_branch", "main")
        commit_message = payload.get("commit_message") or "Add AI generated tests"
        create_pr = payload.get("create_pr", True)
        pr_title = payload.get("pr_title") or "Add AI generated tests"
        pr_body = payload.get("pr_body") or "Generated by AI agent"
        dry_run = bool(payload.get("dry_run", False))
        path_map = payload.get("path_map") or "tests"

        await self.publish_event(request_id, "committing", run_id=run_id, branch=branch)
        tmpdir = self.git_client.make_temp_workdir(f"cicd_{request_id}")
        try:
            repo_path = self.git_client.clone(repo_url, tmpdir, depth=settings.GIT_CLONE_DEPTH)
            logger.info("DEBUG: Cloned repo to %s", repo_path)
            
            if files:
                logger.info("DEBUG: Applying %d files", len(files))
                for f in files:
                    logger.info("DEBUG: File %s, content length %d", f.get("path"), len(f.get("content", "")))
                self.git_client.apply_files(repo_path, files)
                # Verify files were written
                for f in files:
                    target_file = repo_path / f["path"]
                    logger.info("DEBUG: File exists: %s = %s", target_file, target_file.exists())
                    if target_file.exists():
                        logger.info("DEBUG: File content length: %d", len(target_file.read_text()))
            else:
                if not run_id:
                    raise ValueError("run_id is required when files not provided")
                run = self.orchestrator.get_run(run_id)
                if not run or run.get("status") != "finished":
                    raise ValueError("run not finished or not found")
                artifact_path = Path(run["artifact"])
                target_rel = f"{path_map.rstrip('/')}/generated_{run_id}.py"
                logger.info("DEBUG: Copying artifact %s to %s in %s", artifact_path, target_rel, repo_path)
                self.git_client.copy_artifact(artifact_path, target_rel, repo_path)
                target_file = repo_path / target_rel
                logger.info("DEBUG: Artifact copied, exists: %s = %s", target_file, target_file.exists())

            self.git_client.create_branch(repo_path, branch, base=f"origin/{target_branch}")
            logger.info("DEBUG: Created branch %s", branch)
            
            # Stage all changes for diff (needed to see changes)
            import subprocess
            git_path = self.git_client.git_path
            subprocess.run([git_path, "-C", str(repo_path), "add", "."], check=True, capture_output=True)
            logger.info("DEBUG: Staged changes")

            if dry_run:
                diff = self.git_client.diff(repo_path)
                logger.info("DEBUG: Diff length: %d chars", len(diff))
                if not diff:
                    # Try git status to see what's happening
                    status = self.git_client._run_git_capture(["-C", str(repo_path), "status", "--short"])
                    logger.info("DEBUG: Git status: %s", status)
                await self.publish_event(
                    request_id,
                    "preview",
                    branch=branch,
                    diff=diff[:4000],
                )
                return

            self.git_client.commit_all(repo_path, commit_message)
            self.git_client.push(repo_path, repo_url, branch)
            await self.publish_event(request_id, "pushed", branch=branch)

            pr_url = None
            if create_pr:
                owner, repo_name = _extract_owner_repo(repo_url)
                pr_url = self.git_client.create_pr(
                    owner=owner,
                    repo=repo_name,
                    head=branch,
                    base=target_branch,
                    title=pr_title,
                    body=pr_body,
                )
                await self.publish_event(request_id, "pr_created", pr_url=pr_url, branch=branch)

            await self.publish_event(
                request_id,
                "finished",
                branch=branch,
                pr_url=pr_url,
            )
        except (GitClientError, ValueError) as exc:
            logger.exception("commit_push failed: %s", exc)
            await self.publish_event(request_id, "failed", error=str(exc), branch=branch)
        finally:
            try:
                import shutil

                shutil.rmtree(tmpdir, ignore_errors=True)
            except Exception:  # pragma: no cover - best effort
                logger.warning("tmpdir cleanup failed: %s", tmpdir)

    async def publish_event(self, request_id: str, status: str, **extra: Any) -> None:
        payload = {"request_id": request_id, "status": status}
        payload.update(extra)
        # publish is supplied by NATS controller as async function (awaitable)
        await self.publish(payload)


def _extract_owner_repo(repo_url: str) -> tuple[str, str]:
    trimmed = repo_url.rstrip(".git/").split("/")
    if len(trimmed) < 2:
        raise ValueError("Invalid repo url")
    return trimmed[-2], trimmed[-1]
